{
  "version": 3,
  "sources": ["../../textlinestream/dist/textlinestream.es.mjs"],
  "sourcesContent": ["// Vendored from Deno - \n// https://github.com/denoland/deno_std/blob/main/streams/delimiter.ts\n// Copyright 2018-2022 the Deno authors. All rights reserved. MIT license.\n\n/** Transform a stream into a stream where each chunk is divided by a newline,\n * be it `\\n` or `\\r\\n`. `\\r` can be enabled via the `allowCR` option.\n *\n * ```ts\n * import { TextLineStream } from \"./delimiter.ts\";\n * const res = await fetch(\"https://example.com\");\n * const lines = res.body!\n *   .pipeThrough(new TextDecoderStream())\n *   .pipeThrough(new TextLineStream());\n * ```\n */\nclass TextLineStream extends TransformStream {\n  #buf = \"\";\n  #allowCR = false;\n  #returnEmptyLines = false;\n  #mapperFun = line => line;\n  \n  constructor(options) {\n    super({\n      transform: (chunk, controller) => this.#handle(chunk, controller),\n      flush: (controller) => this.#handle(\"\\r\\n\", controller),\n    });\n    \n    this.#allowCR = options?.allowCR ?? false;\n    this.#returnEmptyLines = options?.returnEmptyLines ?? false;\n    this.#mapperFun = options?.mapperFun ?? this.#mapperFun;\n  }\n\n  #handle(chunk, controller) {\n    chunk = this.#buf + chunk;\n\n    for (;;) {\n      const lfIndex = chunk.indexOf(\"\\n\");\n\n      if (this.#allowCR) {\n        const crIndex = chunk.indexOf(\"\\r\");\n\n        if (\n          crIndex !== -1 && crIndex !== (chunk.length - 1) &&\n          (lfIndex === -1 || (lfIndex - 1) > crIndex)\n        ) {\n          const curChunk = this.#mapperFun(chunk.slice(0, crOrLfIndex));\n          if (this.#returnEmptyLines || curChunk) {            \n            controller.enqueue(curChunk);\n          }\n          chunk = chunk.slice(crIndex + 1);\n          continue;\n        }\n      }\n\n      if (lfIndex !== -1) {\n        let crOrLfIndex = lfIndex;\n        if (chunk[lfIndex - 1] === \"\\r\") {\n          crOrLfIndex--;\n        }\n        const curChunk = this.#mapperFun(chunk.slice(0, crOrLfIndex));\n        if (this.#returnEmptyLines || curChunk) {          \n          controller.enqueue(curChunk);\n        }\n        chunk = chunk.slice(lfIndex + 1);\n        continue;\n      }\n\n      break;\n    }\n\n    this.#buf = chunk;\n  }\n}\n\nexport { TextLineStream as default };\n"],
  "mappings": ";;;;;;;;AAAA;AAeA,IAAM,iBAAN,cAA6B,gBAAgB;AAAA,EAM3C,YAAY,SAAS;AACnB,UAAM;AAAA,MACJ,WAAW,CAAC,OAAO,eAAe,sBAAK,sCAAL,WAAa,OAAO;AAAA,MACtD,OAAO,CAAC,eAAe,sBAAK,sCAAL,WAAa,QAAQ;AAAA,IAC9C,CAAC;AAVL;AACE,6BAAO;AACP,iCAAW;AACX,0CAAoB;AACpB,mCAAa,UAAQ;AAQnB,uBAAK,WAAW,mCAAS,YAAW;AACpC,uBAAK,oBAAoB,mCAAS,qBAAoB;AACtD,uBAAK,aAAa,mCAAS,cAAa,mBAAK;AAAA,EAC/C;AA0CF;AAxDE;AACA;AACA;AACA;AAJF;AAiBE,YAAO,SAAC,OAAO,YAAY;AACzB,UAAQ,mBAAK,QAAO;AAEpB,aAAS;AACP,UAAM,UAAU,MAAM,QAAQ,IAAI;AAElC,QAAI,mBAAK,WAAU;AACjB,YAAM,UAAU,MAAM,QAAQ,IAAI;AAElC,UACE,YAAY,MAAM,YAAa,MAAM,SAAS,MAC7C,YAAY,MAAO,UAAU,IAAK,UACnC;AACA,cAAM,WAAW,mBAAK,YAAL,WAAgB,MAAM,MAAM,GAAG,WAAW;AAC3D,YAAI,mBAAK,sBAAqB,UAAU;AACtC,qBAAW,QAAQ,QAAQ;AAAA,QAC7B;AACA,gBAAQ,MAAM,MAAM,UAAU,CAAC;AAC/B;AAAA,MACF;AAAA,IACF;AAEA,QAAI,YAAY,IAAI;AAClB,UAAIA,eAAc;AAClB,UAAI,MAAM,UAAU,CAAC,MAAM,MAAM;AAC/B,QAAAA;AAAA,MACF;AACA,YAAM,WAAW,mBAAK,YAAL,WAAgB,MAAM,MAAM,GAAGA,YAAW;AAC3D,UAAI,mBAAK,sBAAqB,UAAU;AACtC,mBAAW,QAAQ,QAAQ;AAAA,MAC7B;AACA,cAAQ,MAAM,MAAM,UAAU,CAAC;AAC/B;AAAA,IACF;AAEA;AAAA,EACF;AAEA,qBAAK,MAAO;AACd;",
  "names": ["crOrLfIndex"]
}

import {
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet
} from "./chunk-3WN6VOBL.js";

// node_modules/textlinestream/dist/textlinestream.es.mjs
var _buf, _allowCR, _returnEmptyLines, _mapperFun, _TextLineStream_instances, handle_fn;
var TextLineStream = class extends TransformStream {
  constructor(options) {
    super({
      transform: (chunk, controller) => __privateMethod(this, _TextLineStream_instances, handle_fn).call(this, chunk, controller),
      flush: (controller) => __privateMethod(this, _TextLineStream_instances, handle_fn).call(this, "\r\n", controller)
    });
    __privateAdd(this, _TextLineStream_instances);
    __privateAdd(this, _buf, "");
    __privateAdd(this, _allowCR, false);
    __privateAdd(this, _returnEmptyLines, false);
    __privateAdd(this, _mapperFun, (line) => line);
    __privateSet(this, _allowCR, (options == null ? void 0 : options.allowCR) ?? false);
    __privateSet(this, _returnEmptyLines, (options == null ? void 0 : options.returnEmptyLines) ?? false);
    __privateSet(this, _mapperFun, (options == null ? void 0 : options.mapperFun) ?? __privateGet(this, _mapperFun));
  }
};
_buf = new WeakMap();
_allowCR = new WeakMap();
_returnEmptyLines = new WeakMap();
_mapperFun = new WeakMap();
_TextLineStream_instances = new WeakSet();
handle_fn = function(chunk, controller) {
  chunk = __privateGet(this, _buf) + chunk;
  for (; ; ) {
    const lfIndex = chunk.indexOf("\n");
    if (__privateGet(this, _allowCR)) {
      const crIndex = chunk.indexOf("\r");
      if (crIndex !== -1 && crIndex !== chunk.length - 1 && (lfIndex === -1 || lfIndex - 1 > crIndex)) {
        const curChunk = __privateGet(this, _mapperFun).call(this, chunk.slice(0, crOrLfIndex));
        if (__privateGet(this, _returnEmptyLines) || curChunk) {
          controller.enqueue(curChunk);
        }
        chunk = chunk.slice(crIndex + 1);
        continue;
      }
    }
    if (lfIndex !== -1) {
      let crOrLfIndex2 = lfIndex;
      if (chunk[lfIndex - 1] === "\r") {
        crOrLfIndex2--;
      }
      const curChunk = __privateGet(this, _mapperFun).call(this, chunk.slice(0, crOrLfIndex2));
      if (__privateGet(this, _returnEmptyLines) || curChunk) {
        controller.enqueue(curChunk);
      }
      chunk = chunk.slice(lfIndex + 1);
      continue;
    }
    break;
  }
  __privateSet(this, _buf, chunk);
};
export {
  TextLineStream as default
};
//# sourceMappingURL=textlinestream.js.map

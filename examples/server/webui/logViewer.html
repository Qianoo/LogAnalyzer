<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Analyzer Result</title>
    <script src="https://cdn.jsdelivr.net/npm/markdown-it@13.0.1/dist/markdown-it.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
        }

        h1 {
            text-align: center;
            padding: 10px;
            margin: 0;
            background-color: #f5f5f5;
            font-size: 1.5rem;
        }

        #container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        #keyword-list {
            width: 20%;
            background-color: #f8f9fa;
            border-right: 1px solid #dee2e6;
            overflow-y: auto;
            padding: 15px;
        }

        .right-panel {
            width: 80%;
            display: flex;
            flex-direction: column;
        }

        #log-display {
            height: 70%;
            overflow-y: auto;
            padding: 15px;
            border-bottom: 1px solid #dee2e6;
        }

        #analysis-result {
            height: 30%;
            overflow-y: auto;
            padding: 15px;
            background-color: #ffffff;
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .keyword {
            margin: 8px 0;
            padding: 8px 12px;
            background-color: #fff;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .keyword:hover {
            background-color: #e9ecef;
        }

        .highlight {
            background-color: #fff3cd;
            padding: 2px 0;
        }

        .line-number {
            color: #6c757d;
            margin-right: 10px;
            user-select: none;
        }

        .keyword-block {
            margin: 8px 0;
            padding: 6px;
            background-color: #f8f9fa;
            border-radius: 4px;
        }

        .keyword-tags {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
        }

        .keyword-tag {
            font-size: 0.8rem;
            padding: 2px 6px;
            margin: 2px;
            border-radius: 3px;
            background-color: #e7f3ff;
            border: 1px solid #b3d7ff;
            cursor: pointer;
        }

        .keyword-tag:hover {
            background-color: #cce5ff;
        }

        .keyword-tag .line-info {
            font-size: 0.8em;
            color: #666;
            margin-left: 4px;
        }

        .line-highlight {
            background-color: #fff3cd;
            animation: highlight 2s;
        }

        @keyframes highlight {
            from {
                background-color: #ffeeba;
            }

            to {
                background-color: #fff3cd;
            }
        }

        .block-header {
            padding: 5px 10px;
            background-color: #f0f0f0;
            border-bottom: 1px solid #ddd;
            font-weight: bold;
            margin-bottom: 10px;
        }

        #filter-container {
            padding: 8px;
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            background-color: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }

        .filter-tag {
            font-size: 0.8rem;
            padding: 2px 8px;
            border-radius: 4px;
            cursor: pointer;
            background-color: #e9ecef;
            border: 1px solid #dee2e6;
        }

        .filter-tag.active {
            background-color: #28a745;
            color: white;
        }

        .filter-tag.inactive {
            background-color: #e9ecef;
            color: #666;
        }

        .markdown {
            padding: 0.8rem;
            font-size: 0.9rem;
        }

        .markdown h1 {
            font-size: 1.4em;
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .markdown h2 {
            font-size: 1.2em;
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .markdown h3 {
            font-size: 1.1em;
            margin-top: 0.8em;
            margin-bottom: 0.4em;
        }

        .markdown ul,
        .markdown ol {
            padding-left: 1.5em;
            margin-bottom: 0.8em;
        }

        .markdown li {
            margin-bottom: 0.3em;
        }

        .markdown code {
            background-color: #f0f0f0;
            padding: 0.2em 0.4em;
            border-radius: 3px;
            font-family: monospace;
        }

        .markdown pre {
            background-color: #f5f5f5;
            padding: 1em;
            border-radius: 5px;
            overflow-x: auto;
            margin: 1em 0;
        }

        .markdown blockquote {
            border-left: 4px solid #ddd;
            padding-left: 1em;
            margin: 1em 0;
            color: #666;
        }

        .markdown p {
            margin-bottom: 0.8em;
        }

        /* 添加容器样式 */
        .split-container {
            display: flex;
            flex-direction: column;
            height: calc(100vh - 150px);
            /* 减去其他元素的高度 */
            position: relative;
        }

        /* 日志显示窗口 */
        #log-display {
            flex: 1;
            overflow-y: auto;
            padding: 10px;
            min-height: 100px;
            /* 最小高度 */
        }

        /* 可拖动的分隔条 */
        .resizer {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            cursor: row-resize;
            border-top: 1px solid #ddd;
            border-bottom: 1px solid #ddd;
        }

        /* 分隔条中间的线 */
        .resizer::after {
            content: '';
            display: block;
            width: 30px;
            height: 2px;
            background: #999;
            margin: 3px auto;
        }

        /* 分析结果窗口 */
        #analysis-result {
            height: 200px;
            /* 初始高度 */
            overflow-y: auto;
            padding: 10px;
            min-height: 100px;
            /* 最小高度 */
        }

        /* 拖动时的遮罩层 */
        .resize-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            display: none;
        }

        /* 添加进度条样式 */
        .progress-container {
            display: none;
            /* 默认隐藏 */
            width: 100%;
            padding: 10px;
            background-color: #f5f5f5;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .progress-bar {
            width: 0%;
            height: 4px;
            background-color: #4CAF50;
            transition: width 0.3s ease;
        }

        .progress-text {
            font-size: 0.8rem;
            color: #666;
            text-align: center;
            margin-top: 4px;
        }
    </style>
</head>

<body>
    <h1>Analyzer Result</h1>
    <div id="filter-container"></div>
    <div id="container">
        <div id="keyword-list"></div>
        <div class="right-panel">
            <div class="split-container">
                <div id="log-display"></div>
                <div class="resizer"></div>
                <div id="analysis-result">Analysis results will be displayed here.</div>
            </div>
            <div class="flex justify-end mb-4">
                <button id="analyze-btn" class="btn btn-primary">分析日志</button>
            </div>
        </div>
    </div>

    <!-- 添加进度条HTML -->
    <div class="progress-container" id="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
        <div class="progress-text" id="progress-text">正在解析日志...</div>
    </div>

    <script type="module">
        import { parseLogFile } from './src/logParser.js';
        import { getCombinedPrompt } from './src/prompts.js';

        // 确保所有全局变量的定义
        let keywordBlocks = [];
        let lines = [];
        let keywordFilters = new Map();
        let currentAnalysisController = null;  // 添加这个全局变量

        // 获取 DOM 元素引用
        const filterContainer = document.getElementById('filter-container');
        const keywordListElem = document.getElementById('keyword-list');
        const logDisplayElem = document.getElementById('log-display');

        // 创建 markdown-it 实例
        const md = window.markdownit({
            html: true,
            linkify: true,
            typographer: true
        });

        window.addEventListener('message', async (event) => {
            // 立即显示进度条
            const progressContainer = document.getElementById('progress-container');
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');

            // 立即重置和显示进度条
            progressContainer.style.display = 'block';
            progressBar.style.width = '0%';
            progressText.textContent = '正在解析日志文件...';

            // 让UI有时间更新
            await new Promise(resolve => requestAnimationFrame(resolve));

            try {
                // 使用 setTimeout 让进度条有机会显示
                await new Promise(resolve => setTimeout(resolve, 0));

                const logContent = event.data;
                lines = logContent.split('\n');
                const totalLines = lines.length;

                // 1. 解析日志 (30%)
                progressText.textContent = '正在解析日志内容...';

                // 使用 Promise 包装解析过程
                keywordBlocks = await new Promise(resolve => {
                    setTimeout(() => {
                        const blocks = parseLogFile(logContent);
                        progressBar.style.width = '30%';
                        resolve(blocks);
                    }, 0);
                });

                // 2. 处理关键字 (30%-60%)
                progressText.textContent = '正在处理关键字...';

                await new Promise(resolve => setTimeout(resolve, 0));
                const allKeywords = new Set();

                for (let i = 0; i < keywordBlocks.length; i++) {
                    const block = keywordBlocks[i];
                    block.keywords.forEach(keyword => allKeywords.add(keyword));
                    // 更新进度
                    const progress = Math.round(30 + (i / keywordBlocks.length) * 30);
                    progressBar.style.width = `${progress}%`;

                    // 每处理10个块后让出主线程
                    if (i % 10 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // 3. 更新UI (60%-100%)
                progressText.textContent = '正在更新界面...';
                progressBar.style.width = '60%';
                await new Promise(resolve => setTimeout(resolve, 0));

                // 清空容器
                filterContainer.innerHTML = '';
                keywordListElem.innerHTML = '';

                // 重置关键字过滤状态
                keywordFilters = new Map();
                allKeywords.forEach(keyword => keywordFilters.set(keyword, true));

                // 创建过滤器标签
                let processedKeywords = 0;
                const totalKeywords = allKeywords.size;

                for (const keyword of allKeywords) {
                    const filterTag = document.createElement('span');
                    filterTag.className = 'filter-tag active';
                    filterTag.textContent = keyword;
                    filterTag.onclick = () => {
                        const isActive = keywordFilters.get(keyword);
                        keywordFilters.set(keyword, !isActive);
                        filterTag.className = `filter-tag ${!isActive ? 'active' : 'inactive'}`;
                        updateDisplay();
                    };
                    filterContainer.appendChild(filterTag);

                    // 更新进度
                    processedKeywords++;
                    const progress = Math.round(60 + (processedKeywords / totalKeywords) * 20);
                    progressBar.style.width = `${progress}%`;

                    // 每处理5个关键字后让出主线程
                    if (processedKeywords % 5 === 0) {
                        await new Promise(resolve => setTimeout(resolve, 0));
                    }
                }

                // 4. 显示内容
                progressText.textContent = '正在渲染内容...';
                progressBar.style.width = '80%';
                await new Promise(resolve => setTimeout(resolve, 0));

                updateDisplay();

                // 完成
                progressBar.style.width = '100%';
                progressText.textContent = '处理完成';

                // 延迟隐藏进度条
                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 1000);

            } catch (error) {
                console.error('Error processing log:', error);
                progressText.textContent = '处理出错: ' + error.message;
                progressBar.style.backgroundColor = '#ff4444';

                setTimeout(() => {
                    progressContainer.style.display = 'none';
                }, 3000);
            }
        });

        function displayBlockContent(block) {
            logDisplayElem.innerHTML = '';

            const headerElem = document.createElement('div');
            headerElem.className = 'block-header';
            const lineCount = block.endLine - block.startLine + 1;
            const truncatedMessage = lineCount >= 500 ? ' (Truncated to 500 lines)' : '';
            headerElem.textContent = `Log Block (Lines ${block.startLine + 1} - ${block.endLine + 1})${truncatedMessage}`;
            logDisplayElem.appendChild(headerElem);

            const blockLines = lines.slice(block.startLine, block.endLine + 1);
            blockLines.forEach((line, index) => {
                const lineElem = document.createElement('div');
                const actualLineNum = block.startLine + index;
                lineElem.id = `line-${actualLineNum}`;
                lineElem.innerHTML = `<span class="line-number">${actualLineNum + 1}</span>${line}`;

                if (block.keywords.some(keyword =>
                    keywordFilters.get(keyword) && line.includes(keyword))) {
                    lineElem.classList.add('highlight');
                }
                logDisplayElem.appendChild(lineElem);
            });

            if (lineCount >= 500) {
                const truncateNote = document.createElement('div');
                truncateNote.className = 'truncate-note';
                truncateNote.style.color = '#666';
                truncateNote.style.padding = '10px';
                truncateNote.style.fontStyle = 'italic';
                truncateNote.textContent = 'Note: Log block has been truncated to 500 lines for better performance.';
                logDisplayElem.appendChild(truncateNote);
            }
        }

        function updateDisplay() {
            // 停止当前分析
            stopAnalysis();

            keywordListElem.innerHTML = '';

            // 过滤并显示关键字块
            const visibleBlocks = keywordBlocks.filter(block => {
                return block.keywords.some(keyword => keywordFilters.get(keyword));
            });

            visibleBlocks.forEach((block, blockIndex) => {
                const blockElem = document.createElement('div');
                blockElem.className = 'keyword-block';

                const tagsContainer = document.createElement('div');
                tagsContainer.className = 'keyword-tags';

                // 只显示活跃的关键字标签
                const activeKeywords = block.keywords.filter(keyword =>
                    keywordFilters.get(keyword));

                activeKeywords.forEach(keyword => {
                    const tag = document.createElement('span');
                    tag.className = 'keyword-tag';

                    const keywordLines = [];
                    lines.slice(block.startLine, block.endLine + 1).forEach((line, idx) => {
                        if (line.includes(keyword)) {
                            keywordLines.push(block.startLine + idx);
                        }
                    });

                    tag.innerHTML = `${keyword} <span class="line-info">(${keywordLines.length})</span>`;
                    tag.onclick = () => {
                        // 停止当前分析
                        stopAnalysis();

                        displayBlockContent(block);
                        document.querySelectorAll('.line-highlight').forEach(el => {
                            el.classList.remove('line-highlight');
                        });
                        setTimeout(() => {
                            if (keywordLines.length > 0) {
                                const targetLine = document.getElementById(`line-${keywordLines[0]}`);
                                if (targetLine) {
                                    targetLine.scrollIntoView({ behavior: 'smooth', block: 'center' });
                                    targetLine.classList.add('line-highlight');
                                }
                            }
                        }, 100);
                    };
                    tagsContainer.appendChild(tag);
                });

                blockElem.appendChild(tagsContainer);
                keywordListElem.appendChild(blockElem);
            });

            // 如果有显示的块，显示第一个块的内容
            if (visibleBlocks.length > 0) {
                const firstBlock = keywordListElem.querySelector('.keyword-block');
                if (firstBlock) {
                    firstBlock.querySelector('.keyword-tag').click();
                }
            } else {
                logDisplayElem.innerHTML = '<div style="padding: 20px; text-align: center; color: #666;">No matching log blocks</div>';
            }
        }

        // 确保 DOM 加载完成后绑定事件
        document.addEventListener('DOMContentLoaded', () => {
            const analyzeBtn = document.getElementById('analyze-btn');
            if (analyzeBtn) {
                analyzeBtn.addEventListener('click', analyzeLog);
            }
        });

        // 确保 analyzeLog 函数被正确定义
        async function analyzeLog() {
            const logDisplayElem = document.getElementById('log-display');
            const analysisResultElem = document.getElementById('analysis-result');
            const analyzeBtn = document.getElementById('analyze-btn');

            const currentLogContent = logDisplayElem.innerText;

            // 禁用按钮并更新文本
            analyzeBtn.disabled = true;
            analyzeBtn.textContent = '分析中...';

            // 显示等待信息
            analysisResultElem.innerHTML = '<div class="markdown">正在分析，请等待...</div>';

            currentAnalysisController = new AbortController();

            try {
                const chunks = sendSSEPostRequest('/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        messages: [
                            {
                                role: 'system',
                                content: getCombinedPrompt('defaultLogAnalysis')
                            },
                            {
                                role: 'user',
                                content: currentLogContent
                            }
                        ],
                        stream: true
                    }),
                    signal: currentAnalysisController.signal
                });

                // 清空之前的分析结果
                analysisResultElem.innerHTML = '';
                let analysisContent = '';

                for await (const chunk of chunks) {
                    const addedContent = chunk.choices[0].delta.content;
                    if (addedContent) {
                        analysisContent += addedContent;
                        // 使用 markdown-it 渲染内容，并确保包含在 markdown 类中
                        const renderedContent = md.render(analysisContent);
                        analysisResultElem.innerHTML = `<div class="markdown">${renderedContent}</div>`;
                    }
                }
            } catch (error) {
                console.error('Analysis error:', error);
                analysisResultElem.innerHTML = `<div class="markdown">分析出错: ${error.message}</div>`;
            } finally {
                analyzeBtn.disabled = false;
                analyzeBtn.textContent = '分析日志';
            }
        }

        // 添加停止分析的函数
        function stopAnalysis() {
            if (currentAnalysisController) {
                currentAnalysisController.abort();
                currentAnalysisController = null;
            }
            const analysisResultElem = document.getElementById('analysis-result');
            analysisResultElem.innerHTML = '';
        }

        // 添加拖动功能
        function initResizer() {
            const resizer = document.querySelector('.resizer');
            const logDisplay = document.getElementById('log-display');
            const analysisResult = document.getElementById('analysis-result');
            const container = document.querySelector('.split-container');

            let startY;
            let startHeight;

            // 创建遮罩层
            const overlay = document.createElement('div');
            overlay.className = 'resize-overlay';
            document.body.appendChild(overlay);

            function startResize(e) {
                startY = e.clientY;
                startHeight = analysisResult.offsetHeight;
                overlay.style.display = 'block';
                document.addEventListener('mousemove', resize);
                document.addEventListener('mouseup', stopResize);
            }

            function resize(e) {
                const deltaY = startY - e.clientY;
                const newHeight = Math.max(100, Math.min(startHeight + deltaY,
                    container.offsetHeight - 100));
                analysisResult.style.height = newHeight + 'px';
            }

            function stopResize() {
                overlay.style.display = 'none';
                document.removeEventListener('mousemove', resize);
                document.removeEventListener('mouseup', stopResize);
            }

            resizer.addEventListener('mousedown', startResize);
        }

        function parseLogFileWithProgress(logContent, progressCallback) {
            const lines = logContent.split('\n');
            const totalLines = lines.length;
            let processedLines = 0;
            const keywordBlocks = [];
            let currentBlock = null;

            for (let index = 0; index < lines.length; index++) {
                const line = lines[index];

                // 每处理100行更新一次进度
                if (index % 100 === 0) {
                    processedLines = index;
                    progressCallback({
                        percentage: Math.round((processedLines / totalLines) * 100),
                        processedLines,
                        totalLines
                    });
                }

                // 原有的解析逻辑
                // ...
            }

            return keywordBlocks;
        }

        // 添加 sendSSEPostRequest 函数定义
        async function* sendSSEPostRequest(url, options) {
            const response = await fetch(url, options);
            if (!response.ok) {
                throw new Error(`HTTP error! status: ${response.status}`);
            }

            const reader = response.body.getReader();
            const decoder = new TextDecoder();
            let buffer = '';

            while (true) {
                const { value, done } = await reader.read();
                if (done) break;

                buffer += decoder.decode(value, { stream: true });
                const lines = buffer.split('\n');
                buffer = lines.pop() || '';

                for (const line of lines) {
                    if (line.trim() === '') continue;
                    if (line.startsWith('data: ')) {
                        const data = line.slice(6);
                        if (data === '[DONE]') return;
                        try {
                            yield JSON.parse(data);
                        } catch (e) {
                            console.warn('Failed to parse SSE data:', e);
                        }
                    }
                }
            }
        }
    </script>
</body>

</html>